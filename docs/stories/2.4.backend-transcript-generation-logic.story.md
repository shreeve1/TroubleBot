# Story 2.4: Backend Transcript Generation Logic

## Status
Approved

## Story
**As a** developer,
**I want** the backend to receive the full chat history and use the Gemini model to condense it into a summary of key troubleshooting steps,
**so that** a smart transcript can be created.

## Acceptance Criteria
1. A new /generate-transcript endpoint is created.
2. It accepts a chat history payload.
3. It uses a summarization prompt with the Gemini API.
4. It returns a condensed text summary.
5. The endpoint handles errors gracefully and provides meaningful error messages.
6. The transcript generation is optimized for troubleshooting context.

## Tasks / Subtasks
- [x] Create new API endpoint (AC: 1)
  - [x] Create /api/generate-transcript route
  - [x] Set up proper HTTP method (POST)
  - [x] Add request validation for chat history payload
  - [x] Implement proper error handling structure
- [x] Design chat history payload structure (AC: 2)
  - [x] Define TypeScript interfaces for chat history
  - [x] Validate required fields (messages, timestamps, participants)
  - [x] Add payload size limits and validation
  - [x] Create example payload for testing
- [x] Implement summarization prompt (AC: 3, 6)
  - [x] Create specialized prompt for troubleshooting context
  - [x] Design prompt to extract key technical steps
  - [x] Include format instructions for consistent output
  - [x] Add context about escalation purpose
- [x] Integrate with existing Gemini service (AC: 3)
  - [x] Reuse existing AIService class from Story 1.5
  - [x] Extend service for transcript generation
  - [x] Configure appropriate model parameters
  - [x] Add retry logic for API failures
- [x] Process and return condensed summary (AC: 4)
  - [x] Parse Gemini API response
  - [x] Format output for frontend consumption
  - [x] Add metadata (generation timestamp, word count)
  - [x] Structure response for copy-to-clipboard functionality
- [x] Implement comprehensive error handling (AC: 5)
  - [x] Handle API rate limits and timeouts
  - [x] Validate input data quality
  - [x] Provide user-friendly error messages
  - [x] Add logging for debugging
- [x] Add comprehensive testing
  - [x] Unit tests for endpoint functionality
  - [x] Integration tests with mock Gemini responses
  - [x] Error scenario testing
  - [x] Performance testing for large chat histories

## Dev Notes

### Tech Stack Context
- **Backend Framework**: Next.js API Routes ~14.2.3 for serverless functions [Source: architecture/tech-stack.md]
- **Language**: TypeScript ~5.4.5 for type-safe serverless functions [Source: architecture/tech-stack.md]
- **External APIs**: Gemini API for AI processing [Source: architecture/tech-stack.md]
- **Logging**: Vercel Log Drains for serverless function logs [Source: architecture/tech-stack.md]

### Project Structure Requirements
- API routes in apps/web/pages/api/ [Source: architecture/unified-project-structure.md]
- No database required (stateless) [Source: architecture/tech-stack.md]
- No authentication required [Source: architecture/tech-stack.md]
- Reuse existing AIService from apps/web/utils/ai.ts [Source: stories/1.5.core-ai-integration.story.md]

### Testing Standards
- **Backend Testing**: Jest ~29.7.0 for API testing [Source: architecture/tech-stack.md]
- **E2E Testing**: Playwright ~1.44.1 for transcript generation testing [Source: architecture/tech-stack.md]
- Multi-layered strategy following "testing pyramid" [Source: architecture/testing-strategy.md]

### File Locations
- apps/web/pages/api/generate-transcript.ts: New transcript generation endpoint
- apps/web/utils/ai.ts: Existing AI service (needs extension)
- apps/web/types/chat.ts: New TypeScript interfaces for chat history
- apps/web/__tests__/api/generate-transcript.test.ts: New API tests

### Technical Constraints
- Serverless functions must be stateless [Source: architecture/tech-stack.md]
- No persistent data storage required [Source: architecture/tech-stack.md]
- Must reuse existing Gemini API integration
- Response time should be reasonable for user experience (< 10 seconds)
- Payload size limits for serverless function constraints

### Previous Story Insights
- Core AI integration functional with AIService class [Source: stories/1.5.core-ai-integration.story.md]
- Session-end escalation modal implemented [Source: stories/2.3.session-end-escalation-prompt.story.md]
- Existing /api/chat endpoint working with Gemini API
- Mock mode available for development without real API key

### Chat History Payload Structure
```typescript
interface ChatMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: string;
}

interface ChatHistory {
  messages: ChatMessage[];
  sessionId: string;
  escalationReason?: string;
}

interface TranscriptResponse {
  summary: string;
  generatedAt: string;
  wordCount: number;
  sessionId: string;
}
```

### Summarization Prompt Design
The prompt should:
- Focus on technical troubleshooting steps
- Extract key decisions and actions taken
- Identify root cause analysis
- Include any solutions attempted
- Format for ticketing system compatibility
- Maintain professional tone for escalation

### Error Handling Strategy
- **Input Validation**: Validate chat history structure and content
- **API Errors**: Handle Gemini API rate limits, timeouts, and failures
- **Size Limits**: Check payload size and message count limits
- **Content Quality**: Validate that chat history contains meaningful content
- **Graceful Degradation**: Provide fallback responses when possible

### Performance Considerations
- **Response Time**: Target < 10 seconds for typical chat histories
- **Payload Limits**: Consider Vercel serverless function limits
- **Caching**: No caching required (stateless)
- **Optimization**: Efficient prompt design to minimize token usage

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-19 | 1.0 | Initial story creation | Bob (SM) |
| 2025-07-20 | 1.1 | Story implementation completed | James (Dev) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4-20250514

### Debug Log References
- Fixed test validation for empty request body edge case in node-mocks-http
- All tests passing: 11 frontend tests + 6 chat API tests + 6 echo API tests + 12 transcript API tests = 36 total tests
- Console.error logs in tests are expected behavior for error scenario testing

### Completion Notes List
- Created comprehensive /api/generate-transcript endpoint with full validation
- Extended AIService class with generateTranscript() method and specialized prompting
- Implemented robust chat history validation with size limits and format checking
- Added comprehensive error handling for rate limits, API failures, and invalid inputs
- Created detailed TypeScript interfaces for all chat and transcript data structures
- Designed professional summarization prompt optimized for technical support escalation
- Added mock mode support for development and testing without real API keys
- Implemented word count, timestamps, and metadata for transcript responses
- Created extensive test suite covering all acceptance criteria and edge cases
- Followed existing patterns and reused AIService architecture from Story 1.5

### File List
- apps/web/pages/api/generate-transcript.ts (new - transcript generation API endpoint)
- apps/web/utils/ai.ts (modified - extended AIService with transcript generation)
- apps/web/types/chat.ts (new - TypeScript interfaces for chat and transcript data)
- apps/web/__tests__/api/generate-transcript.test.ts (new - comprehensive test suite)

## QA Results
TBD 